[["index.html", "中文书模板 1 简介", " 中文书模板 zzw 2022年1月5日 1 简介 R软件的bookdown扩展包是R Markdown的增强版， 支持自动目录、文献索引、公式编号与引用、定理编号与引用、图表自动编号与引用等功能， 可以作为LaTeX的一种替代解决方案， 在制作用R进行数据分析建模的技术报告时， 可以将报告文字、R程序、文字性结果、表格、图形都自动地融合在最后形成的网页或者PDF文件中。 Bookdown使用的设置比较复杂， 对初学者不够友好。 这里制作了一些模板， 用户只要解压缩打包的文件， 对某个模板进行修改填充就可以变成自己的中文图书或者论文。 Bookdown的详细用法参见https://bookdown.org/yihui/bookdown/， 在李东风的《统计软件教程》也有部分介绍。 一些常用功能的示例在0101-usage.Rmd文件中， 用户可以在编辑器中打开此文件参考其中的做法。 Bookdown如果输出为网页， 其中的数学公式需要MathJax程序库的支持， 用如下数学公式测试浏览器中数学公式显示是否正常： \\[ \\text{定积分} = \\int_a^b f(x) \\,dx \\] 如果显示不正常， 可以在公式上右键单击， 选择“Math Settings–Math Renderer”， 依次使用改成“Common HTML”，“SVG”等是否可以变成正常显示。 PDF版本不存在这样的问题。 "],["causal.html", "2 格兰格因果性 2.1 介绍 2.2 格兰格因果性的定义", " 2 格兰格因果性 2.1 介绍 考虑两个时间序列之间的因果性。 这里的因果性指的是时间顺序上的关系， 如果\\(X_{t-1}, X_{t-2}, \\dots\\)对\\(Y_t\\)有作用， 而\\(Y_{t-1}, Y_{t-2}, \\dots\\)对\\(X_t\\)没有作用， 则称\\(\\{X_t \\}\\)是\\(\\{ Y_t \\}\\)的格兰格原因， 而\\(\\{ Y_t \\}\\)不是\\(\\{ X_t \\}\\)的格兰格原因。 如果\\(X_{t-1}, X_{t-2}, \\dots\\)对\\(Y_t\\)有作用， \\(Y_{t-1}, Y_{t-2}, \\dots\\)对\\(X_t\\)也有作用， 则在没有进一步信息的情况下无法确定两个时间序列的因果性关系。 注意这种因果性与采样频率有关系， 在日数据或者月度数据中能发现的领先——滞后性质的因果关系， 到年度数据可能就以及混杂在以前变成同步的关系了。 2.2 格兰格因果性的定义 设\\(\\{ \\xi_t \\}\\)为一个时间序列， \\(\\{ \\boldsymbol{\\eta}_t \\}\\)为向量时间序列， 记 \\[\\begin{aligned} \\bar{\\boldsymbol{\\eta}}_t =&amp; \\{ \\boldsymbol{\\eta}_{t-1}, \\boldsymbol{\\eta}_{t-2}, \\dots \\} \\end{aligned}\\] 记 \\(\\text{Pred}(\\xi_t | \\bar{\\boldsymbol{\\eta}}_t)\\)为基于 \\(\\boldsymbol{\\eta}_{t-1}, \\boldsymbol{\\eta}_{t-2}, \\dots\\) 对\\(\\xi_t\\)作的最小均方误差无偏预报， 其解为条件数学期望\\(E(\\xi_t | \\boldsymbol{\\eta}_{t-1}, \\boldsymbol{\\eta}_{t-2}, \\dots)\\)， 在一定条件下可以等于\\(\\xi_t\\)在\\(\\boldsymbol{\\eta}_{t-1}, \\boldsymbol{\\eta}_{t-2}, \\dots\\)张成的线性Hilbert空间的投影 （比如，\\((\\xi_t, \\boldsymbol{\\eta}_t)\\)为平稳正态多元时间序列）， 即最优线性预测。 直观理解成基于过去的\\(\\{\\boldsymbol{\\eta}_{t-1}, \\boldsymbol{\\eta}_{t-2}, \\dots \\}\\)的信息对当前的\\(\\xi_t\\)作的最优预测。 令一步预测误差为 \\[ \\varepsilon(\\xi_t | \\bar{\\boldsymbol{\\eta}}_t) = \\xi_t - \\text{Pred}(\\xi_t | \\bar{\\boldsymbol{\\eta}}_t) \\] 令一步预测误差方差，或者均方误差， 为 \\[ \\sigma^2(\\xi_t | \\bar{\\boldsymbol{\\eta}}_t) = \\text{Var}(\\varepsilon_t(\\xi_t | \\bar{\\boldsymbol{\\eta}}_t) ) = E \\left[ \\xi_t - \\text{Pred}(\\xi_t | \\bar{\\boldsymbol{\\eta}}_t) \\right]^2 \\] 考虑两个时间序列\\(\\{ X_t \\}\\)和\\(\\{ Y_t \\}\\)， \\(\\{(X_t, Y_t) \\}\\)宽平稳或严平稳。 如果 \\[ \\sigma^2(Y_t | \\bar Y_t, \\bar X_t) &lt; \\sigma^2(Y_t | \\bar Y_t) \\] 则称\\(\\{ X_t \\}\\)是\\(\\{ Y_t \\}\\)的格兰格原因， 记作\\(X_t \\Rightarrow Y_t\\)。 这不排除\\(\\{ Y_t \\}\\)也可以是\\(\\{ X_t \\}\\)的格兰格原因。 如果\\(X_t \\Rightarrow Y_t\\)，而且\\(Y_t \\Rightarrow X_t\\)， 则称互相有反馈关系， 记作\\(X_t \\Leftrightarrow Y_t\\)。 如果 \\[ \\sigma^2(Y_t | \\bar Y_t, X_t, \\bar X_t) &lt; \\sigma^2(Y_t | \\bar Y_t, \\bar X_t) \\] 即除了过去的信息， 增加同时刻的\\(X_t\\)信息后对\\(Y_t\\)预测有改进， 则称\\(\\{X_t \\}\\)对\\(\\{Y_t \\}\\)有瞬时因果性。 这时\\(\\{Y_t \\}\\)对\\(\\{X_t \\}\\)也有瞬时因果性。 如果\\(X_t \\Rightarrow Y_t\\)， 则存在最小的正整数\\(m\\)， 使得 \\[ \\sigma^2(Y_t | \\bar Y_t, X_{t-m}, X_{t-m-1}, \\dots) &lt; \\sigma^2(Y_t | \\bar Y_t, X_{t-m-1}, X_{t-m-2}, \\dots) \\] 称\\(m\\)为因果性滞后值(causality lag)。 如果\\(m&gt;1\\)， 这意味着在已有\\(Y_{t-1}, Y_{t-2}, \\dots\\)和\\(X_{t-m}, X_{t-m-1}, \\dots\\)的条件下， 增加\\(X_{t-1}\\), , \\(X_{t-m+1}\\)不能改进对\\(Y_t\\)的预测。 例2.1 设\\(\\{ \\varepsilon_t, \\eta_t \\}\\)是相互独立的零均值白噪声列， \\(\\text{Var}(\\varepsilon_t)=1\\), \\(\\text{Var}(\\eta_t)=1\\), 考虑 \\[\\begin{aligned} Y_t =&amp; X_{t-1} + \\varepsilon_t \\\\ X_t =&amp; \\eta_t + 0.5 \\eta_{t-1} \\end{aligned}\\] 用\\(L(\\cdot|\\cdot)\\)表示最优线性预测，则 \\[\\begin{aligned} &amp; L(Y_t | \\bar Y_t, \\bar X_t) \\\\ =&amp; L(X_{t-1} | X_{t-1}, \\dots, Y_{t-1}, \\dots) + L(\\varepsilon_t | \\bar Y_t, \\bar X_t) \\\\ =&amp; X_{t-1} + 0 \\\\ =&amp; X_{t-1} \\\\ \\sigma(Y_t | \\bar Y_t, \\bar X_t) =&amp; \\text{Var}(\\varepsilon_t) = 1 \\end{aligned}\\] 而 \\[ Y_t = \\eta_{t-1} + 0.5\\eta_{t-2} + \\varepsilon_t \\] 有 \\[\\begin{aligned} \\gamma_Y(0) = 2.25, \\gamma_Y(1) = 0.5, \\gamma_Y(k) = 0, k \\geq 2 \\end{aligned}\\] 所以\\(\\{Y_t \\}\\)是一个MA(1)序列， 设其方程为 \\[ Y_t = \\zeta_t + b \\zeta_{t-1}, \\zeta_t \\sim \\text{WN}(0, \\sigma_\\zeta^2) \\] 可以解出 \\[\\begin{aligned} \\rho_Y(1) =&amp; \\frac{\\gamma_Y(1)}{\\gamma_Y(0)} = \\frac{2}{9} \\\\ b =&amp; \\frac{1 - \\sqrt{1 - 4 \\rho_Y^2(1)}}{2 \\rho_Y(1)} \\approx 0.2344 \\\\ \\sigma_\\zeta^2 =&amp; \\frac{\\gamma_Y(1)}{b} \\approx 2.1328 \\end{aligned}\\] 于是 \\[\\begin{aligned} \\sigma(Y_t | \\bar Y_t) =&amp; \\sigma_\\zeta^2 = 2.1328 \\end{aligned}\\] 所以 \\[\\begin{aligned} \\sigma(Y_t | \\bar Y_t, \\bar X_t) = 1 &lt; 2.1328 = \\sigma(Y_t | \\bar Y_t) \\end{aligned}\\] 即\\(X_t\\)是\\(Y_t\\)的格兰格原因。 反之， \\(X_t\\)是MA(1)序列， 有 \\[ \\eta_t = \\frac{1}{1 + 0.5 B} X_t = \\sum_{j=0}^\\infty (-0.5)^j X_{t-j} \\] 其中\\(B\\)是推移算子（滞后算子）。 于是 \\[\\begin{aligned} L(X_t | \\bar X_t) =&amp; L(\\eta_t | \\bar X_t) + 0.5 L(\\eta_{t-1} | \\bar X_t) \\\\ =&amp; 0.5 \\sum_{j=0}^\\infty (-0.5)^j X_{t-1-j} \\\\ =&amp; - \\sum_{j=1}^\\infty (-0.5)^j X_{t-j} \\\\ \\sigma(X_t | \\bar X_t) =&amp; \\text{Var}(X_t - L(X_t | \\bar X_t)) \\\\ =&amp; \\text{Var}(\\eta_t) = 1 \\end{aligned}\\] 而 \\[\\begin{aligned} L(X_t | \\bar X_t, \\bar Y_t) =&amp; L(\\eta_t | \\bar X_t, \\bar Y_t) + 0.5 L(\\eta_{t-1} | \\bar X_t, \\bar Y_t) \\\\ =&amp; 0 + 0.5 L(\\sum_{j=0}^\\infty (-0.5)^j X_{t-1-j} | \\bar X_t, \\bar Y_t) \\\\ =&amp; -\\sum_{j=1}^\\infty (-0.5)^j X_{t-j} \\\\ =&amp; L(X_t | \\bar X_t) \\end{aligned}\\] 所以\\(Y_t\\)不是\\(X_t\\)的格兰格原因。 考虑瞬时因果性。 \\[\\begin{aligned} L(Y_t | \\bar X_t, \\bar Y_t, X_t) =&amp; X_{t-1} + 0 (\\text{注意}\\varepsilon_t\\text{与}\\{X_s, \\forall s\\}\\text{不相关} \\\\ =&amp; L(Y_t | \\bar X_t, \\bar Y_t) \\end{aligned}\\] 所以\\(X_t\\)不是\\(Y_t\\)的瞬时格兰格原因。 ○○○○○ 例2.2 在例2.1中，如果模型改成 \\[\\begin{aligned} Y_t =&amp; X_{t} + \\varepsilon_t \\\\ X_t =&amp; \\eta_t + 0.5 \\eta_{t-1} \\end{aligned}\\] 有怎样的结果？ 这时 \\[ Y_t = \\varepsilon_t + \\eta_t + 0.5 \\eta_{t-1} \\] 仍有 \\[\\begin{aligned} \\gamma_Y(0) = 2.25, \\gamma_Y(1) = 0.5, \\gamma_Y(k) = 0, k \\geq 2 \\end{aligned}\\] 所以\\(Y_t\\)还服从MA(1)模型 \\[ Y_t = \\zeta_t + b \\zeta_{t-1}, b \\approx 0.2344, \\sigma^2_\\zeta \\approx 2.1328 \\] \\[\\begin{aligned} L(Y_t | \\bar Y_t, \\bar X_t) =&amp; L(X_t | \\bar Y_t, \\bar X_t) + 0 \\\\ =&amp; L(\\eta_t | \\bar Y_t, \\bar X_t) + 0.5 L(\\eta_{t-1} | \\bar Y_t, \\bar X_t) \\\\ =&amp; 0 + 0.5 L(\\sum_{j=0}^\\infty (-0.5)^j X_{t-1-j} | \\bar Y_t, \\bar X_t) \\\\ =&amp; - \\sum_{j=1}^\\infty (-0.5)^j X_{t-j} \\\\ =&amp; X_t - \\eta_t \\\\ \\sigma(Y_t | \\bar Y_t, \\bar X_t) =&amp; \\text{Var}(\\varepsilon_t + \\eta_t) = 2 \\end{aligned}\\] 而 \\[ \\sigma(Y_t | \\bar Y_t) = \\sigma^2_\\zeta \\approx 2.1328 &gt; \\sigma(Y_t | \\bar Y_t, \\bar X_t) = 2 \\] 所以\\(X_t\\)是\\(Y_t\\)的格兰格原因。 反之， \\[\\begin{aligned} L(X_t | \\bar X_t, \\bar Y_t) =&amp; - \\sum_{j=1}^\\infty (-0.5)^j X_{t-j} \\\\ =&amp; L(X_t | \\bar X_t) \\end{aligned}\\] 所以\\(Y_t\\)不是\\(X_t\\)的格兰格原因。 考虑瞬时因果性。 \\[\\begin{aligned} L(Y_t | \\bar X_t, \\bar Y_t, X_t) =&amp; X_{t} + 0 (\\text{注意}\\varepsilon_t\\text{与}\\{X_s, \\forall s\\}\\text{不相关} \\\\ =&amp; X_t \\\\ \\sigma(Y_t | \\bar X_t, \\bar Y_t, X_t) =&amp; \\text{Var}(\\varepsilon) \\\\ =&amp; 1 &lt; 2 = \\sigma(Y_t | \\bar X_t, \\bar Y_t) \\end{aligned}\\] 所以\\(X_t\\)是\\(Y_t\\)的瞬时格兰格原因。 \\[\\begin{aligned} [aaa] \\end{aligned}\\] "],["id_1.html", "3 Network Analysis in R 3.1 Basic Concepts and Applications 3.2 Directed networks 3.3 Network Structure 3.4 Do birds of a feather flock together?", " 3 Network Analysis in R 3.1 Basic Concepts and Applications 3.1.1 Basic Concepts about Graph vertex(or node) edge direct or undirect graph This course is using igraph for working with network data and network visualizing. For creating an igraph object , you can use graph.edgelist() ,but remember convert data to matrix form. The position of the nodes and edges of the graph is not important (for now), what is important is the relationship between each node. Another function to create an igraph object is graph_from_data_frame(). Two data frames need to be provided - one contains all edges in the network with attributes and one all vertices in the network. V(): returns all vertices in a network. E(): returns all edges. gorder() : returns number of vertices. gsize() : returns number of edges. # Create an igraph object, first you need to convert data to matrix form friends.mat &lt;- as.matrix(friends) # Convert friends matrix to an igraph object g &lt;- graph.edgelist(friends.mat, directed = FALSE) # Another way to create igraph object g1 &lt;- graph_from_data_frame(d = friends.edges, vertices = friends.nodes, directed = FALSE) # Subset vertices and edges V(g) ## + 16/16 vertices, named, from f064c29: ## [1] Jessie Sidney Britt Donnie Karl Berry Rene Shayne Elisha ## [10] Whitney Odell Lacy Eugene Jude Rickie Tommy E(g) ## + 27/27 edges from f064c29 (vertex names): ## [1] Jessie --Sidney Jessie --Britt Sidney --Britt Sidney --Donnie ## [5] Karl --Berry Sidney --Rene Britt --Rene Sidney --Shayne ## [9] Sidney --Elisha Sidney --Whitney Jessie --Whitney Donnie --Odell ## [13] Sidney --Odell Rene --Whitney Donnie --Shayne Jessie --Lacy ## [17] Rene --Lacy Elisha --Eugene Eugene --Jude Berry --Odell ## [21] Odell --Rickie Karl --Odell Britt --Lacy Elisha --Jude ## [25] Whitney--Lacy Britt --Whitney Karl --Tommy gorder(g) # as as vcount(g) ## [1] 16 gsize(g) ## [1] 27 # Make a very basic plot of the network plot(g) 3.1.2 Add and Visualizing attributes Vertices and edges could have attributes. - set_vertex_attr() : add attributes to vertices. - set_edge_attr() : add attributes to edges. You can use V() to view attributes of vertices in a dataframe. When attributes are added, something interesting is about to begin . You can subset vertices and edges by specific conditions or delete them. # suppose you have three attributes genders &lt;- friends.nodes$gender ages &lt;- sample(18:23, size = 16, replace = TRUE) hours &lt;- friends.edges$hours # Create new vertex attributes called &#39;gender&#39; and &#39;age&#39; g &lt;- set_vertex_attr(g, &quot;gender&quot;, value = genders) ## Warning in vattrs[[name]][index] &lt;- value: number of items to replace is not a ## multiple of replacement length g &lt;- set_vertex_attr(g, &quot;age&quot;, value = ages) # Create new edge attribute called &#39;hours&#39; g &lt;- set_edge_attr(g, &#39;hours&#39;, value = hours) ## Warning in eattrs[[name]][index] &lt;- value: number of items to replace is not a ## multiple of replacement length # View all vertex and edge attributes in a list vertex_attr(g) ## $name ## [1] &quot;Jessie&quot; &quot;Sidney&quot; &quot;Britt&quot; &quot;Donnie&quot; &quot;Karl&quot; &quot;Berry&quot; &quot;Rene&quot; ## [8] &quot;Shayne&quot; &quot;Elisha&quot; &quot;Whitney&quot; &quot;Odell&quot; &quot;Lacy&quot; &quot;Eugene&quot; &quot;Jude&quot; ## [15] &quot;Rickie&quot; &quot;Tommy&quot; ## ## $gender ## [1] &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; ## ## $age ## [1] 21 21 19 21 20 19 21 23 20 22 21 20 21 23 20 18 edge_attr(g) ## $hours ## [1] 1 3 2 3 5 1 3 5 2 1 3 5 3 2 6 1 2 2 1 1 2 1 1 3 2 1 3 # Find edges with conditions, this grammar is like the way Python takes a subset # V(g)[[age == 22]] # E(g)[[inc(&#39;Lacy&#39;)]] # E(g)[[hours&gt;=3]] # Delete edges and vertices g1_1 &lt;- delete_edges(g1, E(g1)[hours &lt; 2]) g1_2 &lt;- delete_vertices(g, V(g)[[age &lt;20]]) # Visualizing attributes paste(&quot;This graph tells me that boys prefer to make friends and their relationship graph is more aggregated&quot;) ## [1] &quot;This graph tells me that boys prefer to make friends and their relationship graph is more aggregated&quot; # Set vertex color by gender V(g1)$color &lt;- ifelse(V(g1)$gender == &quot;F&quot;, &quot;orange&quot;, &quot;#24addb&quot;) # Plot the graph plot(g1, vertex.label.color = &quot;black&quot;) 3.1.3 Network Visualization The most effective network visualizations should immediately provide insight and understanding to the viewer. These styles below can be done separately or in conjunction with each other. Vertices Style - size - labels - color - shape Edges Style - color - line type Appropriate Layout - Minimize edge crossing - Do not allow vertices to overlap - Make edge lengths as uniform as possible - Increase symmetry of the network as much as possible - Position more influential nodes towards the center In the plot() function, change the layout argument to produce different graph layout. Choosing a correct layout can be bewildering. Fortunately igraph has a function layout_nicely() that tries to choose the most appropriate layout function for a given graph object. circle layout_in_circle() fruchterman-reingold: layout_with_fr(), details on Wiki kamada-kawai: layout_with_fr() grid: layout_on_grid() lgl: layout_with_lgl() tree: layout_as_tree() (For more layouts see the manual on igraph website) You can also stipulate the layout by providing a matrix of (x, y) coordinates for each vertex. Here you use the layout_as_tree() function to generate the matrix m of coordinates. Then pass m to the layout function in plot() to plot. # Visualization in layout plot(g1, vertex.label.color = &quot;black&quot;, layout = layout_in_circle(g1)) plot(g1, vertex.label.color = &quot;black&quot;, layout = layout_with_fr(g1)) m &lt;- layout_as_tree(g1) plot(g1, vertex.label.color = &quot;black&quot;, layout = m) m1 &lt;- layout_nicely(g1) plot(g1, vertex.label.color = &quot;black&quot;, layout = m1) # Visualiztion in edges # Create a vector of weights based on the number of hours each pair spend together w1 &lt;- E(g1)$hours # Plot the network varying edges by weights m1 &lt;- layout_nicely(g1) plot(g1, vertex.label.color = &quot;black&quot;, edge.color = &#39;black&#39;, edge.width = w1, layout = m1) 3.2 Directed networks 3.2.1 Basic Concepts head -&gt; tail The edges in undirected networks simply indicate that a relationship of some kind exists between two vertices. However, in many networks edges do have directionality. In such directed networks, an arrow represent an edge going from one vertex to another vertex. Subset each vertex from which each edge originates by using head_of(). This function takes two arguments, the first being the graph object and the second the edges to examine. For all edges you can use E(g) The example network you will use is of a severe measles outbreak that spread through the town of Hagelloch, Germany, in 1861, affecting 188 children. Each edge represents the transmission of measles from one individual to the next. # Get the graph object g2 &lt;- graph_from_data_frame(measles, directed = TRUE) # is the graph directed? is.directed(g2) ## [1] TRUE # Where does each edge originate from? But I don&#39;t understand the result ... # table(head_of(g2, E(g2))) plot(g2, vertex.label.color = &quot;black&quot;, edge.color = &#39;gray77&#39;, vertex.size = 0, edge.arrow.size = 0.1, layout = layout_nicely(g2)) 3.2.2 Relationships between edges Check if there is an edge going in each direction between vertex 184 to vertex 178 using single brackets subsetting of the graph object. Using the function incident() identify those edges that go in either direction from vertex 184 or only those going out from vertex 184. Choose mode from all, in and out. # Is there an edge going from vertex 184 to vertex 178? g2[&#39;184&#39;, &#39;178&#39;] ## [1] 1 # Is there an edge going from vertex 178 to vertex 184? g2[&#39;178&#39;, &#39;184&#39;] ## [1] 0 # Show all edges going to or from vertex 184 incident(g2, &#39;184&#39;, mode = c(&quot;all&quot;)) ## + 6/184 edges from f0df7cd (vertex names): ## [1] 184-&gt;45 184-&gt;182 184-&gt;181 184-&gt;178 184-&gt;183 184-&gt;177 # Show all edges going out from vertex 184 incident(g2, &#39;184&#39;, mode = c(&quot;out&quot;)) ## + 6/184 edges from f0df7cd (vertex names): ## [1] 184-&gt;45 184-&gt;182 184-&gt;181 184-&gt;178 184-&gt;183 184-&gt;177 3.2.3 Relationships between vertices neighbors(): A vertex is a neighbor of another one (in other words, the two vertices are adjacent), if they are incident to the same edge. intersection(): to identify if there are any vertices that exist in both neighbors1 and neighbors1. A path is simply the chain of connections between vertices. The number of intervening edges between two vertices represents the geodesic distance between vertices. farthest_vertices(): Find the length of the longest path in the network(Sometimes it can be more than one). get_diameter() : Identify the sequence of the path. ego(): Find the vertices not farther than a given limit from another fixed vertex, these are called the neighborhood of the vertex. # Identify neighbors of vertex 10 in specific mode neighbors(g2, &#39;10&#39;, mode = c(&#39;all&#39;)) ## + 5/187 vertices, named, from f0df7cd: ## [1] 45 27 48 71 95 neighbors(g2, &#39;10&#39;, mode = c(&#39;in&#39;)) ## + 1/187 vertex, named, from f0df7cd: ## [1] 45 # Identify any vertices that receive an edge from vertex 42 and direct an edge to vertex 124 n1 &lt;- neighbors(g2, &#39;42&#39;, mode = c(&#39;out&#39;)) n2 &lt;- neighbors(g2, &#39;124&#39;, mode = c(&#39;in&#39;)) intersection(n1, n2) ## + 1/187 vertex, named, from f0df7cd: ## [1] 7 # distance between two vertices farthest_vertices(g2) ## $vertices ## + 2/187 vertices, named, from f0df7cd: ## [1] 184 162 ## ## $distance ## [1] 5 get_diameter(g2) ## + 6/187 vertices, named, from f0df7cd: ## [1] 184 178 42 7 123 162 ego(g2, 2, &#39;10&#39;, mode = c(&#39;out&#39;)) ## [[1]] ## + 5/187 vertices, named, from f0df7cd: ## [1] 10 27 48 71 95 3.2.4 Identifying key vertices Measurement metrics: - in degree - out degree - Betweenness Betweenness is an index of how frequently the vertex lies on shortest paths between any two vertices in the network. It can be thought of as how critical the vertex is to the flow of information through a network. # Calculate the out-degree of each vertex g.outd &lt;- degree(g2, mode = c(&quot;out&quot;)) table(g.outd) ## g.outd ## 0 1 2 3 4 6 7 8 30 ## 125 21 16 12 6 2 3 1 1 # Make a histogram of out-degrees hist(g.outd, breaks = 30) # Find the vertex that has the maximum out-degree which.max(g.outd) ## 45 ## 1 plot(g2, vertex.label = NA, edge.color = &#39;black&#39;, vertex.size = sqrt(g.outd)+1, edge.arrow.size = 0.05, layout = layout_nicely(g2)) # Calculate betweenness of each vertex g.b &lt;- betweenness(g2, directed = TRUE) hist(g.b, breaks = 80) # Create plot with vertex size determined by betweenness score plot(g2, vertex.label = NA, edge.color = &#39;black&#39;, vertex.size = sqrt(g.b)+1, edge.arrow.size = 0.05, layout = layout_nicely(g2)) make_ego_graph() : Create a subset of our network comprised of vertices that are connected to fixed vertex , the first argument is the original graph g, the second argument is the maximal number of connections that any vertex needs to be connected to our vertex of interest. One issue with the measles dataset is that there are three individuals for whom no information is known about who infected them. One of these individuals (vertex 184) appears ultimately responsible for spreading the disease to many other individuals even though they did not directly infect too many individuals. (This entire paragraph is excerpted from the course) However, because vertex 184 has no incoming edge in the network they appear to have low betweenness. One way to explore the importance of this vertex is by visualizing the geodesic distances of connections going out from this individual. In this exercise you shall create a plot of these distances from this patient zero. (This entire paragraph is excerpted from the course) # Make an ego graph g184 &lt;- make_ego_graph(g2, diameter(g2), nodes = &#39;184&#39;, mode = c(&quot;all&quot;))[[1]] # Get a vector of geodesic distances of all vertices from vertex 184 dists &lt;- distances(g184, &quot;184&quot;) # Create a color palette of length equal to the maximal geodesic distance plus one. colors &lt;- c(&quot;black&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;dodgerblue&quot;, &quot;cyan&quot;) # Set color attribute to vertices of network g184. V(g184)$color &lt;- colors[dists+1] # Visualize the network based on geodesic distance from vertex 184 (patient zero). plot(g184, vertex.label = dists, vertex.label.color = &quot;white&quot;, vertex.label.cex = .6, edge.color = &#39;black&#39;, vertex.size = 7, edge.arrow.size = .05, main = &quot;Geodesic Distances from Patient Zero&quot; ) 3.3 Network Structure 3.3.1 Basic Structure metrics eigen_centrality() : takes a graph (graph) and returns the eigenvector centralities of positions v within it You will use a social network based on the movie Forrest Gump. Each edge of the network indicates that those two characters were in at least one scene of the movie together. Therefore this network is undirected. # Make an undirected network g3 &lt;- graph_from_data_frame(gump, directed = FALSE) # Identify key nodes using eigenvector centrality g.ec &lt;- eigen_centrality(g3) which.max(g.ec$vector) ## FORREST ## 36 # Plot Forrest Gump Network plot(g3, vertex.label.color = &quot;black&quot;, vertex.label.cex = 0.6, vertex.size = 25*(g.ec$vector), edge.color = &#39;gray88&#39;, main = &quot;Forrest Gump Network&quot; ) edge_density() : calculate the edge density of the graph mean_distance() : calculate the average path length of the graph # Get density of a graph gd &lt;- edge_density(g3) # The diameter of a graph is the length of the longest geodesic. diameter(g3, directed = FALSE) ## [1] 4 # Get the average path length of the graph g g.apl &lt;- mean_distance(g3, directed = FALSE) g.apl ## [1] 1.994967 3.3.2 Random graphs Generating random graphs is an important method for investigating how likely or unlikely other network metrics are likely to occur given certain properties of the original graph. The simplest random graph is one that has the same number of vertices as your original graph and approximately the same density as the original graph.(This entire paragraph is excerpted from the course) erdos.renyi.game() : generate random graphs according to the Erdos-Renyi model, more function details on igraph. g.random &lt;- erdos.renyi.game(n = gorder(g3), p.or.m = gd, type = &quot;gnp&quot;) plot(g.random, vertex.label = NA, vertex.size = 1, ) # Get density of new random graph `g.random` edge_density(g.random) ## [1] 0.06634637 # Get the average path length of the random graph g.random mean_distance(g.random, directed = FALSE) ## [1] 2.673073 3.3.3 Randomization test The Forrest Gump network was smaller than the average path length of the random network, you can more formally address this by creating 1000 random graphs based on the number of vertices and density of the original Forrest Gump graph. Then, you can see how many times the average path length of the random graphs is less than the original Forrest Gump network. This is called a randomization test.(This entire paragraph is excerpted from the course) Conclusion : the Forrest Gump network is far more interconnected than we would expect by chance. # Generate 1000 random graphs gl &lt;- vector(&#39;list&#39;, 1000) for(i in 1:1000){ gl[[i]] &lt;- erdos.renyi.game(n = gorder(g3), p.or.m = gd, type = &quot;gnp&quot;) } # Calculate average path length of 1000 random graphs gl.apls &lt;- unlist(lapply(gl, mean_distance, directed = FALSE)) # Plot the distribution of average path lengths hist(gl.apls, xlim = range(c(1.5, 6)), breaks = 5) abline(v = mean_distance(g3,directed=FALSE), col = &quot;red&quot;, lty = 3, lwd = 2) # Calculate the proportion of graphs with an average path length lower than our observed mean(gl.apls &lt; mean_distance(g3,directed = FALSE)) ## [1] 0 3.3.4 Network substructures’ metrics triangles() : find all closed triangles in the graph count_triangles() : count how many triangles a vertex is part of, in a graph, or just list the triangles of a graph. transitivity() : transitivity measures the probability that the adjacent vertices of a vertex are connected. You can use this function to get the global or local transitivity. Also, you can use randomization test to investigate if the global transitivity of the Forrest Gump network is significantly higher.(Conclusion : Yes) Clique : In a clique, every vertex is connected to every other vertex. largest_cliques() : identify the largest cliques in the network max_cliques() : determine all the maximal cliques in the network # Show all triangles in the network. matrix(triangles(g3), nrow = 3) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 1 1 1 1 2 4 4 6 6 6 6 7 7 8 ## [3,] 83 38 39 66 68 57 24 27 75 40 45 8 69 69 ## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 11 11 11 12 12 13 14 14 14 14 14 14 ## [3,] 12 13 70 70 13 70 4 19 24 71 65 57 ## [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 14 14 14 15 15 17 17 18 18 19 19 21 ## [3,] 62 63 64 21 72 22 42 5 28 71 63 72 ## [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 22 24 26 26 26 26 26 26 27 27 27 28 ## [3,] 42 57 73 52 47 48 49 50 75 45 40 5 ## [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 28 30 30 30 34 38 38 38 39 39 40 40 ## [3,] 90 84 61 51 88 83 66 39 83 66 75 45 ## [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 41 41 41 41 41 41 41 41 41 41 41 41 ## [3,] 1 3 6 7 8 11 12 13 26 27 30 32 ## [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 41 41 41 41 41 41 41 41 41 41 41 41 ## [3,] 33 86 37 38 39 40 43 44 45 47 48 49 ## [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98] ## [1,] 36 36 36 36 36 36 36 36 36 36 36 36 ## [2,] 41 41 41 41 41 41 41 41 41 41 41 41 ## [3,] 50 51 52 53 54 56 58 61 66 69 70 73 ## [,99] [,100] [,101] [,102] [,103] [,104] [,105] [,106] [,107] [,108] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 41 41 41 41 41 41 43 43 43 44 ## [3,] 74 75 79 82 83 84 82 54 53 2 ## [,109] [,110] [,111] [,112] [,113] [,114] [,115] [,116] [,117] [,118] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 44 44 44 44 44 44 44 44 44 44 ## [3,] 3 9 14 17 19 22 82 71 42 43 ## [,119] [,120] [,121] [,122] [,123] [,124] [,125] [,126] [,127] [,128] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 44 44 44 44 44 45 47 47 47 47 ## [3,] 53 62 63 64 65 75 73 52 50 48 ## [,129] [,130] [,131] [,132] [,133] [,134] [,135] [,136] [,137] [,138] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 47 48 48 48 48 49 49 49 50 50 ## [3,] 49 73 52 50 49 73 52 50 73 52 ## [,139] [,140] [,141] [,142] [,143] [,144] [,145] [,146] [,147] [,148] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 51 51 52 53 54 54 56 58 59 60 ## [3,] 84 61 73 82 87 56 89 79 92 2 ## [,149] [,150] [,151] [,152] [,153] [,154] [,155] [,156] [,157] [,158] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 60 60 60 60 60 60 61 62 62 62 ## [3,] 20 23 25 31 81 43 84 71 19 35 ## [,159] [,160] [,161] [,162] [,163] [,164] [,165] [,166] [,167] [,168] ## [1,] 36 36 36 36 36 36 36 36 36 36 ## [2,] 62 63 64 64 64 64 64 64 65 65 ## [3,] 63 71 3 71 19 63 62 46 4 71 ## [,169] [,170] [,171] [,172] [,173] [,174] [,175] [,176] [,177] [,178] ## [1,] 36 36 36 36 36 36 36 41 41 41 ## [2,] 65 65 65 65 65 65 66 1 1 1 ## [3,] 19 24 64 63 57 62 83 83 38 39 ## [,179] [,180] [,181] [,182] [,183] [,184] [,185] [,186] [,187] [,188] ## [1,] 41 41 41 41 41 41 41 41 41 41 ## [2,] 1 6 6 6 6 7 7 8 11 11 ## [3,] 66 27 75 40 45 8 69 69 12 13 ## [,189] [,190] [,191] [,192] [,193] [,194] [,195] [,196] [,197] [,198] ## [1,] 41 41 41 41 41 41 41 41 41 41 ## [2,] 11 12 12 13 26 26 26 26 26 26 ## [3,] 70 70 13 70 73 52 47 48 49 50 ## [,199] [,200] [,201] [,202] [,203] [,204] [,205] [,206] [,207] [,208] ## [1,] 41 41 41 41 41 41 41 41 41 41 ## [2,] 27 27 27 30 30 30 38 38 38 39 ## [3,] 75 45 40 84 61 51 83 66 39 83 ## [,209] [,210] [,211] [,212] [,213] [,214] [,215] [,216] [,217] [,218] ## [1,] 41 41 41 41 41 41 41 41 41 41 ## [2,] 39 40 40 43 43 43 44 44 44 44 ## [3,] 66 75 45 82 54 53 3 82 43 53 ## [,219] [,220] [,221] [,222] [,223] [,224] [,225] [,226] [,227] [,228] ## [1,] 41 41 41 41 41 41 41 41 41 41 ## [2,] 45 47 47 47 47 47 48 48 48 48 ## [3,] 75 73 52 50 48 49 73 52 50 49 ## [,229] [,230] [,231] [,232] [,233] [,234] [,235] [,236] [,237] [,238] ## [1,] 41 41 41 41 41 41 41 41 41 41 ## [2,] 49 49 49 50 50 51 51 52 53 54 ## [3,] 73 52 50 73 52 84 61 73 82 56 ## [,239] [,240] [,241] [,242] [,243] [,244] [,245] [,246] [,247] [,248] ## [1,] 41 41 41 41 44 44 44 44 44 44 ## [2,] 58 58 61 66 2 14 14 14 14 14 ## [3,] 10 79 84 83 67 19 71 65 62 63 ## [,249] [,250] [,251] [,252] [,253] [,254] [,255] [,256] [,257] [,258] ## [1,] 44 44 44 44 44 44 44 44 44 44 ## [2,] 14 17 17 19 19 22 43 43 53 62 ## [3,] 64 22 42 71 63 42 82 53 82 71 ## [,259] [,260] [,261] [,262] [,263] [,264] [,265] [,266] [,267] [,268] ## [1,] 44 44 44 44 44 44 44 44 44 44 ## [2,] 62 62 63 64 64 64 64 64 65 65 ## [3,] 19 63 71 3 71 19 63 62 71 19 ## [,269] [,270] [,271] [,272] [,273] [,274] [,275] [,276] [,277] [,278] ## [1,] 44 44 44 14 14 14 14 14 14 14 ## [2,] 65 65 65 4 4 19 19 24 65 65 ## [3,] 64 63 62 57 24 71 63 57 4 71 ## [,279] [,280] [,281] [,282] [,283] [,284] [,285] [,286] [,287] [,288] ## [1,] 14 14 14 14 14 14 14 14 14 14 ## [2,] 65 65 65 65 65 65 62 62 62 63 ## [3,] 19 24 64 63 57 62 71 19 63 71 ## [,289] [,290] [,291] [,292] [,293] [,294] [,295] [,296] [,297] [,298] ## [1,] 14 14 14 14 65 65 65 65 65 65 ## [2,] 64 64 64 64 4 4 19 19 24 64 ## [3,] 71 19 63 62 57 24 71 63 57 71 ## [,299] [,300] [,301] [,302] [,303] [,304] [,305] [,306] [,307] [,308] ## [1,] 65 65 65 65 65 65 65 64 64 64 ## [2,] 64 64 64 63 62 62 62 19 19 63 ## [3,] 19 63 62 71 71 19 63 71 63 71 ## [,309] [,310] [,311] [,312] [,313] [,314] [,315] [,316] [,317] [,318] ## [1,] 64 64 64 62 62 62 19 26 26 26 ## [2,] 62 62 62 19 19 63 63 52 47 47 ## [3,] 71 19 63 71 63 71 71 73 73 52 ## [,319] [,320] [,321] [,322] [,323] [,324] [,325] [,326] [,327] [,328] ## [1,] 26 26 26 26 26 26 26 26 26 26 ## [2,] 47 47 47 48 48 48 48 49 49 49 ## [3,] 50 48 49 73 52 50 49 73 52 50 ## [,329] [,330] [,331] [,332] [,333] [,334] [,335] [,336] [,337] [,338] ## [1,] 26 26 47 47 47 47 47 47 47 47 ## [2,] 50 50 52 50 50 48 48 48 48 49 ## [3,] 73 52 73 73 52 73 52 50 49 73 ## [,339] [,340] [,341] [,342] [,343] [,344] [,345] [,346] [,347] [,348] ## [1,] 47 47 48 48 48 48 48 48 49 49 ## [2,] 49 49 52 50 50 49 49 49 52 50 ## [3,] 52 50 73 73 52 73 52 50 73 73 ## [,349] [,350] [,351] [,352] [,353] [,354] [,355] [,356] [,357] [,358] ## [1,] 49 50 43 1 1 1 1 1 1 6 ## [2,] 50 52 53 38 38 38 39 39 66 27 ## [3,] 52 73 82 83 66 39 83 66 83 75 ## [,359] [,360] [,361] [,362] [,363] [,364] [,365] [,366] [,367] [,368] ## [1,] 6 6 6 6 6 27 27 27 38 38 ## [2,] 27 27 40 40 45 45 40 40 66 39 ## [3,] 45 40 75 45 75 75 75 45 83 83 ## [,369] [,370] [,371] [,372] [,373] [,374] [,375] [,376] [,377] [,378] ## [1,] 38 39 40 4 11 11 11 12 30 30 ## [2,] 39 66 45 24 12 12 13 13 61 51 ## [3,] 66 83 75 57 70 13 70 70 84 84 ## [,379] [,380] [,381] [,382] [,383] [,384] ## [1,] 30 51 7 17 18 15 ## [2,] 51 61 8 22 28 21 ## [3,] 61 84 69 42 5 72 # Count the number of triangles that vertex &quot;BUBBA&quot; is in. count_triangles(g3, vids=&#39;BUBBA&#39;) ## [1] 37 # Calculate the global transitivity of the network. g.tr &lt;- transitivity(g3) g.tr ## [1] 0.1918082 # Calculate the local transitivity for vertex BOB HOPE. transitivity(g3, vids=&#39;BOB HOPE&#39;, type = &quot;local&quot;) ## [1] 1 gl.tr &lt;- lapply(gl, transitivity) gl.trs &lt;- unlist(gl.tr) # Calculate the proportion of graphs with a transitivity score higher than Forrest Gump&#39;s network mean(gl.trs &gt; g.tr) ## [1] 0 largest_cliques(g3) ## [[1]] ## + 9/94 vertices, named, from f2132b6: ## [1] EMCEE FORREST MEN MAN #5 MAN #3 MAN #2 MAN #1 MAN # JENNY ## ## [[2]] ## + 9/94 vertices, named, from f2132b6: ## [1] FORREST LT DAN STRONGARM SONG SOLDIER SGT SIMS MAN ## [8] DALLAS BUBBA clq &lt;- max_cliques(g3) # some confusing in function name # Calculate the size of each maximal clique. table(unlist(lapply(clq, length))) ## ## 2 3 4 5 6 7 9 ## 12 24 7 2 4 2 2 3.3.5 Visualize largest cliques Steps are: - You need get the largest cliques(may not one) - Subset from the original graph - Plot it with circle layout Then you can change some arguments in plot function, I want to make them simple . lc &lt;- largest_cliques(g3) # Create two new undirected subgraphs, each containing only the vertices of each largest clique. gs1 &lt;- as.undirected(subgraph(g3, lc[[1]])) gs2 &lt;- as.undirected(subgraph(g3, lc[[2]])) par(mfrow=c(1,2)) # To plot two plots side-by-side plot(gs1, vertex.label = NA, vertex.size = 0, edge.color = &#39;gray28&#39;, #main = &quot;Largest Clique 1&quot;, layout = layout.circle(gs1) ) plot(gs2, vertex.label = NA, #vertex.label.color = &quot;black&quot;, #vertex.label.cex = 0.9, vertex.size = 0, edge.color = &#39;gray28&#39;, #main = &quot;Largest Clique 2&quot;, layout = layout.circle(gs2) ) 3.4 Do birds of a feather flock together? Assortativity assortativity() : calculate the assortativity based on specific attribute .The assortativity coefficient is positive is similar vertices (based on some external property) tend to connect to each, and negative otherwise. assortativity.degree() : calculate the degree assortativity of the network . Reciprocity reciprocity() : the reciprocity of a directed network reflects the proportion of edges that are symmetrical. You can also do randomization test to these two metrics. # Convert the gender attribute into a numeric value values &lt;- as.numeric(factor(V(g1)$gender)) # Calculate the assortativity of the network based on gender assortativity(g1, values) ## [1] 0.1319444 # Calculate the assortativity degree of the network assortativity.degree(g1, directed = FALSE) ## [1] 0.4615385 # Calculate the reciprocity of the direct graph reciprocity(g2) ## [1] 0 3.4.1 Community detection If a network is said to have a community structure then it is possible to assign vertices to unique sets. - fastgreedy.community() : a community detection method . - edge.betweenness.community() : an alternative community detection method. - sizes() : determine how many communities were detected and how many club members are in each. - membership() : display which club members are in which community. - disjoint_union(): the union of two or more graphs are created. The graphs are assumed to have disjoint vertex sets. Notice: - x %du% y is a simplified form of disjoint_union(...), and this example is from igraph document. - Because the division of this figure is so obvious, there is no difference between the two methods # Create a graph g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5) g &lt;- add_edges(g, c(1,6, 1,11, 6, 11)) # make community detection fc &lt;- fastgreedy.community(g) gc &lt;- edge.betweenness.community(g) # view metrics sizes(fc) ## Community sizes ## 1 2 3 ## 5 5 5 membership(fc) ## [1] 3 3 3 3 3 1 1 1 1 1 2 2 2 2 2 sizes(gc) ## Community sizes ## 1 2 3 ## 5 5 5 # Because this graph is par(mfrow = c(1, 2)) plot(fc, g) plot(gc, g) 3.4.2 Interactive network visualizations There are many other R packages that also make network visualizations. igraph visNetwork statnet networkD3 ggnet sigma ggnetwork rgexf(igraph to Gephi) ggraph threejs The threejs package is especially useful for visualizing large networks and integrates very well with igraph. And you can use it to create interactive network visualization. graphjs(g1, vertex.size = 1) # Another unrelated but unprecedented operation that I have not encountered before i &lt;- membership(fc) c(&quot;yellow&quot;, &quot;blue&quot;, &quot;red&quot;)[i] ## [1] &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;red&quot; &quot;yellow&quot; &quot;yellow&quot; &quot;yellow&quot; ## [9] &quot;yellow&quot; &quot;yellow&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; &quot;blue&quot; "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
